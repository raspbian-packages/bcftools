Description: Fix spelling errors
Author: Afif Elghraoui <afif@ghraoui.name>
Forwarded: no
Last-Update: 2015-11-09
--- bcftools.orig/doc/bcftools.1
+++ bcftools/doc/bcftools.1
@@ -465,7 +465,7 @@
 .\}
 .SS "bcftools annotate \fI[OPTIONS]\fR \fIFILE\fR"
 .sp
-This command allows to add or remove annotations\&.
+This command allows one to add or remove annotations\&.
 .PP
 \fB\-a, \-\-annotations\fR \fIfile\fR
 .RS 4
@@ -779,7 +779,7 @@
 likelihood of novel mutation for constrained
 \fB\-C\fR
 \fItrio\fR
-calling\&. The trio genotype calling maximizes likelihood of a particular combination of genotypes for father, mother and the child P(F=i,M=j,C=k) = P(unconstrained) * Pn + P(constrained) * (1\-Pn)\&. By providing three values, the mutation rate Pn is set explictly for SNPs, deletions and insertions, respectively\&. If two values are given, the first is interpreted as the mutation rate of SNPs and the second is used to calculate the mutation rate of indels according to their length as Pn=\fIfloat\fR*exp(\-a\-b*len), where a=22\&.8689, b=0\&.2994 for insertions and a=21\&.9313, b=0\&.2856 for deletions [pubmed:23975140]\&. If only one value is given, the same mutation rate Pn is used for SNPs and indels\&.
+calling\&. The trio genotype calling maximizes likelihood of a particular combination of genotypes for father, mother and the child P(F=i,M=j,C=k) = P(unconstrained) * Pn + P(constrained) * (1\-Pn)\&. By providing three values, the mutation rate Pn is set explicitly for SNPs, deletions and insertions, respectively\&. If two values are given, the first is interpreted as the mutation rate of SNPs and the second is used to calculate the mutation rate of indels according to their length as Pn=\fIfloat\fR*exp(\-a\-b*len), where a=22\&.8689, b=0\&.2994 for insertions and a=21\&.9313, b=0\&.2856 for deletions [pubmed:23975140]\&. If only one value is given, the same mutation rate Pn is used for SNPs and indels\&.
 .RE
 .PP
 \fB\-p, \-\-pval\-threshold\fR \fIfloat\fR
@@ -2123,7 +2123,7 @@
 // Longer description used by \*(Aqbcftools +name \-h\*(Aq
 const char *usage(void);
 
-// Called once at startup, allows to initialize local variables\&.
+// Called once at startup, allows one to initialize local variables\&.
 // Return 1 to suppress normal VCF/BCF header output, \-1 on critical
 // errors, 0 otherwise\&.
 int init(int argc, char **argv, bcf_hdr_t *in_hdr, bcf_hdr_t *out_hdr);
--- bcftools.orig/vcfcall.c
+++ bcftools/vcfcall.c
@@ -169,7 +169,7 @@
         sam = add_sample(sam, &n, &max, col_ends[0]+1, ploidy, &j);
         if ( strcmp(col_ends[1]+1,"0") )    // father
         {
-            if ( fam->sample[CHILD]>=0 ) error("Multiple childs in %s [%s,%s]\n", str.s, sam[j],sam[fam->sample[CHILD]]);
+            if ( fam->sample[CHILD]>=0 ) error("Multiple children in %s [%s,%s]\n", str.s, sam[j],sam[fam->sample[CHILD]]);
             fam->sample[CHILD] = j;
             if ( fam->sample[FATHER]>=0 ) error("Two fathers in %s?\n", str.s);
             sam = add_sample(sam, &n, &max, col_ends[1]+1, call->flag & (CALL_CHR_X|CALL_CHR_Y) ? 1 : 2, &fam->sample[FATHER]);
@@ -189,7 +189,7 @@
     }
     assert( n==_n );
     for (i=0; i<call->nfams; i++)
-        assert( call->fams[i].sample[0]>=0 && call->fams[i].sample[1]>=0 && call->fams[i].sample[2]>=0 ); // multiple childs, not a trio
+        assert( call->fams[i].sample[0]>=0 && call->fams[i].sample[1]>=0 && call->fams[i].sample[2]>=0 ); // multiple children, not a trio
 
     return sam;
 }
